/*
*  copyright 2015 James Ingram
*  https://james-ingram-act-two.de/
*
*  Code licensed under MIT
*
*  This file contains the implementation of the WebMIDISynthHost's GUI. 
*  The WebMIDISynthHost can host one or more WebMIDISynths and use one
*  or more SoundFonts.
*/

/*global WebMIDI, window,  document, performance */

WebMIDI.namespace('host');

WebMIDI.host = (function(document)
{
    "use strict";

    var
        synth = null,
        inputDevice = null,
        currentChannel = 0,
        notesAreSounding = false,
        allLongInputControls = [], // used by AllControllersOff control

        triggerKey,

        getElem = function(elemID)
        {
            return document.getElementById(elemID);
        },

        setInputDeviceEventListener = function(inputDeviceSelect)
        {
            function handleInputMessage(e)
            {
                // Rectifiy performed velocities so that they are in range [6..127].
                // The velocities generated by my E-MU keyboard are in range [20..127]
                // So: (deviceVelocity - 20) is in range [0..107],
                // ((deviceVelocity - 20) * 121 / 107) is in range [0..121],
                // (121 / 107) is ca. 1.1308
                // and (6 + Math.round(((deviceVelocity - 20) * 1.1308))) is in range [6..127]
                // (The E-MU keyboard's velocity response curve is set to its curve option number 5.)
                function getRectifiedEMUVelocity(deviceVelocity)
                {
                    let rectifiedVelocity = deviceVelocity; // can be 0 (E-MU sends 0 for NoteOff)
                    if(rectifiedVelocity >= 20)
                    {
                        rectifiedVelocity = 6 + Math.round((deviceVelocity - 20) * 1.1308);
                    }
                    console.log("emuVel=" + deviceVelocity.toString() + " vel=" + rectifiedVelocity.toString());

                    return rectifiedVelocity;
                }

                function updateGUI_ControlsTable(ccIndex, ccValue)
                {
                    let longInputControls = allLongInputControls.filter(elem => elem.numberInputElem.ccIndex === ccIndex);

                    // longInputControls.length will be > 1 if there is more than one regParam control.
                    // This function simply updates all the regParam controls even though only one of them has changed.
                    for(var i = 0; i < longInputControls.length; i++)
                    {
                        let longInputControl = longInputControls[i];
                        if(ccIndex === WebMIDI.constants.CONTROL.DATA_ENTRY)
                        {
                            console.assert(longInputControl.numberInputElem.regParam !== undefined);
                        }

                        longInputControl.setValue(ccValue);
                    }
                }

                function updateGUI_CommandsTable(cmdIndex, cmdValue)
                {
                    let longInputControl = allLongInputControls.find(elem => elem.numberInputElem.cmdIndex === cmdIndex);

                    longInputControl.setValue(cmdValue);
                }

                function doTriggerAction()
                {
                    // Returns the channel's next action definition.
                    // Throws an exception if the channel has no actions or no nextActionIndex or no action at the required index.
                    function getNextActionDef(channel)
                    {
                        let channelState = synth.channelControls[channel],
                            actions = channelState.actions,
                            nextActionIndex = channelState.nextActionIndex;

                        if(actions === undefined || nextActionIndex === undefined || nextActionIndex < 0 || nextActionIndex >= actions.length)
                        {
                            throw "undefined action";
                        }
                        return actions[nextActionIndex];
                    }

                    // Throws an exception if index is out of range.
                    function checkSelectRange(index, select)
                    {
                        if(index < 0 || index >= select.options.length)
                        {
                            throw "index out of range";
                        }
                    }

                    function doAction(actionDef)
                    {
                        if(actionDef.presetIndex !== undefined)
                        {
                            checkSelectRange(actionDef.presetIndex, presetSelect);
                            presetSelect.selectedIndex = actionDef.presetIndex;
                            onPresetSelectChanged();
                        }
                        if(actionDef.tuningIndex !== undefined)
                        {
                            checkSelectRange(actionDef.tuningIndex, tuningSelect);
                            tuningSelect.selectedIndex = actionDef.tuningIndex;
                            onTuningSelectChanged();
                        }
                    }

                    function incrementActionPointer(channel)
                    {
                        let channelState = synth.channelControls[channel],
                            nActions = channelState.actions.length,
                            nextActionIndex = channelState.nextActionIndex;

                        if(nextActionIndex === nActions - 1)
                        {
                            channelState.nextActionIndex = 0;
                        }
                        else
                        {
                            channelState.nextActionIndex++;
                        }
                    }

                    let channel = getElem("channelSelect").selectedIndex,
                        presetSelect = getElem("presetSelect"),
                        tuningSelect = getElem("tuningSelect"),
                        actionDef = getNextActionDef(channel);

                    doAction(actionDef);
                    incrementActionPointer(channel);
                }

                let data = e.data,
                    CMD = WebMIDI.constants.COMMAND,
                    cmdIndex = data[0] & 0xF0;

                if(triggerKey !== undefined && cmdIndex === CMD.NOTE_ON && data[1] === triggerKey)
                {
                    if(data[2] !== 0)
                    {
                        doTriggerAction();
                    }
                }
                else if(!(cmdIndex === CMD.NOTE_OFF && data[1] === triggerKey)) // EMU never sends NOTE_OFF, but anyway...
                {
                    let msg = new Uint8Array([((cmdIndex + currentChannel) & 0xFF), data[1], data[2]]);

                    switch(cmdIndex)
                    {
                        case CMD.NOTE_OFF:
                            break;
                        case CMD.NOTE_ON:
                            if(inputDevice.name.localeCompare("E-MU Xboard49") === 0)
                            {
                                msg[2] = getRectifiedEMUVelocity(msg[2]);
                            }
                            //console.log("NoteOn: key=" + data[1] + ", velocity=" + data[2]);
                            break;
                        case CMD.AFTERTOUCH:
                            // The EMU keyboard never sends aftertouch, so this should never happen.
                            console.assert(false);
                            break;
                        case CMD.CONTROL_CHANGE:
                            updateGUI_ControlsTable(data[1], data[2]);
                            //console.log("control change: " + getMsgString(data));
                            break;
                        case CMD.PRESET:
                            //console.log("preset: " + getMsgString(data));
                            break;
                        case CMD.CHANNEL_PRESSURE:
                            //console.log("channel pressure: value=" + data[1]);
                            break;
                        case CMD.PITCHWHEEL:
                            // This host uses pitchwheel values in range 0..127, so data[1] (the fine byte) is ignored here.
                            // But note that the residentSynth _does_ use both data[1] and data[2] when responding
                            // to PITCHWHEEL messages (including those that come from the E-MU keyboard), so PITCHWHEEL
                            // messages sent from this host's GUI use a data[1] value that is calculated on the fly.
                            updateGUI_CommandsTable(cmdIndex, data[2]);
                            //console.log("pitchWheel: value=" + data[2]);
                            break;
                        default:
                            console.warn("Unknown command sent from midi input device.");
                            break;
                    }
                    synth.send(msg, performance.now());
                }
            }

            if(inputDevice !== null)
            {
                inputDevice.removeEventListener("midimessage", handleInputMessage, false);
                inputDevice.close();
            }

            inputDevice = inputDeviceSelect.options[inputDeviceSelect.selectedIndex].inputDevice;
            if(inputDevice)
            {
                inputDevice.addEventListener("midimessage", handleInputMessage, false);
                inputDevice.open();
            }
            else
            {
                alert("Can't open input device.");
                inputDeviceSelect.selectedIndex = 0;
            }
        },

        // exported
        onInputDeviceSelectChanged = function()
        {
            let ids = getElem("inputDeviceSelect");

            if(ids.selectedIndex > 0)
            {
                setInputDeviceEventListener(ids);
            }
            else
            {
                inputDevice = null;
            }
        },

        // Called by 'gitHub' and 'website' buttons
        openInNewTab = function(url)
        {
            var win = window.open(url, '_blank');
            win.focus();
        },

        // exported
        webAudioFontWebsiteButtonClick = function()
        {
            let webAudioFontSelect = getElem("webAudioFontSelect"),
                selectedOption = webAudioFontSelect[webAudioFontSelect.selectedIndex];

            openInNewTab(selectedOption.url);
        },

        // Disables the triggerKeySelect if the channel has no defined actions.
        // Sets actionNameCell.InnerHTML to "" if actionIndex is undefined.
        // Otherwise throws an exception either if there is no action at actionIndex,
        // or if the action has no name attribute.
        setTriggersDiv = function(channelIndex, actionIndex)
        {
            let triggerKeySelect = getElem("triggerKeySelect"),
                actionNameCell = getElem("actionNameCell"),
                channelActionDefs = synth.actionDefs[channelIndex];

            if(channelActionDefs === undefined || channelActionDefs.actions === undefined)
            {
                triggerKeySelect.disabled = true;
                actionNameCell.innerHTML = "This channel has no defined actions";
            }
            else if(actionIndex === undefined)
            {
                triggerKeySelect.disabled = false;
                actionNameCell.innerHTML = "";
            }
            else if(channelActionDefs.actions[actionIndex] === undefined)
            {
                throw "Application error: action index out of range.";
            }
            else if(channelActionDefs.actions[actionIndex].name === undefined)
            {
                throw "Configuration error: action has no name.";
            }
            else
            {
                triggerKeySelect.disabled = false;
                actionNameCell.innerHTML = "action: " + channelActionDefs.actions[actionIndex].name;
            }
        },

        // exported
        onChannelSelectChanged = function()
        {
            function setAndSendPresetFromState(channelGUIState)
            {
                let fontSelectIndex = channelGUIState.fontSelectIndex, // index in webAudioFontSelect
                    presetSelectIndex = channelGUIState.presetSelectIndex, // index in presetSelect
                    fontSelect = getElem("webAudioFontSelect"),
                    presetSelect = getElem("presetSelect");

                fontSelect.selectedIndex = fontSelectIndex;
                onWebAudioFontSelectChanged(); // sets the soundFont in the synth

                presetSelect.selectedIndex = presetSelectIndex; // sets the presetSelect
                onPresetSelectChanged();  // sets the preset in the synth
            }

            function setAndSendTuningFromState(channelGUIState)
            {
                let tuningGroupSelectIndex = channelGUIState.tuningGroupSelectIndex,
                    A4FrequencySelectIndex = channelGUIState.A4FrequencySelectIndex,
                    tuningSelectIndex = channelGUIState.tuningSelectIndex,
                    tuningGroupSelect = getElem("tuningGroupSelect"),
                    A4FrequencySelect = getElem("A4FrequencySelect"),
                    tuningSelect = getElem("tuningSelect"),
                    selectedTuningGroupOption,
                    tuningOptionsArray;

                tuningGroupSelect.selectedIndex = tuningGroupSelectIndex;

                selectedTuningGroupOption = tuningGroupSelect[tuningGroupSelect.selectedIndex];
                tuningOptionsArray = selectedTuningGroupOption.tuningOptionsArray;
                setOptions(tuningSelect, tuningOptionsArray);

                A4FrequencySelect.selectedIndex = A4FrequencySelectIndex;
                tuningSelect.selectedIndex = tuningSelectIndex;

                onTuningSelectChanged(); // sets the tuning in the synth (reads the channelSelect)
            }

            function setTriggerDivFromState(channelGUIState)
            {
                let triggerKeySelectIndex = channelGUIState.triggerKeySelectIndex,
                    //triggerActionSelectIndex = channelGUIState.triggerActionSelectIndex,
                    triggerActionDescription = channelGUIState.nextActionDescription,
                    triggerKeySelect = getElem("triggerKeySelect"),
                    triggerActionCell = getElem("triggerActionCell");

                triggerKeySelect.selectedIndex = triggerKeySelectIndex;
                triggerKey = triggerKeySelect[triggerKeySelect.selectedIndex].key;

                triggerActionCell.innerHTML = triggerActionDescription;
            }

            function setAndSendLongControlsFromState(channelGUIState)
            {
                let aftertouchLC = getElem("aftertouchLongControl"),
                    pitchWheelLC = getElem("pitchWheelLongControl"),
                    modWheelLC = getElem("modWheelLongControl"),
                    volumeLC = getElem("volumeLongControl"),
                    panLC = getElem("panLongControl"),
                    reverberationLC = getElem("reverberationLongControl"),
                    pitchWheelSensitivityLC = getElem("pitchWheelSensitivityLongControl");

                aftertouchLC.setValue(channelGUIState.aftertouchValue);
                pitchWheelLC.setValue(channelGUIState.pitchWheelValue);
                modWheelLC.setValue(channelGUIState.modWheelValue);
                volumeLC.setValue(channelGUIState.volumeValue);
                panLC.setValue(channelGUIState.panValue);
                reverberationLC.setValue(channelGUIState.reverberationValue);
                pitchWheelSensitivityLC.setValue(channelGUIState.pitchWheelSensitivityValue);
            }

            let channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                channelGUIState = channelSelect.options[channel].hostState;

            currentChannel = channel; // the global currentChannel is used by synth.send(...)

            setAndSendPresetFromState(channelGUIState);
            setAndSendTuningFromState(channelGUIState);
            setTriggerDivFromState(channelGUIState);

            setAndSendLongControlsFromState(channelGUIState);
        },

        // exported
        onPresetSelectChanged = function()
        {
            function getBankMsg(channel, bankIndex)
            {
                return new Uint8Array([CMD.CONTROL_CHANGE + channel, CTL.BANK, bankIndex]);
            }

            function getPresetMsg(channel, presetIndex)
            {
                return new Uint8Array([CMD.PRESET + channel, presetIndex]);
            }

            function getMixtureMessages(channel, mixtureIndex)
            {
                let regParam = new Uint8Array([CMD.CONTROL_CHANGE + channel, CTL.REGISTERED_PARAMETER, synth.REGPARAM_SET_MIXTURE_INDEX]),
                    dataEntry;

                if(mixtureIndex === undefined)
                {
                    dataEntry = new Uint8Array([CMD.CONTROL_CHANGE + channel, CTL.DATA_ENTRY]);
                }
                else
                {
                    dataEntry = new Uint8Array([CMD.CONTROL_CHANGE + channel, CTL.DATA_ENTRY, mixtureIndex]);
                }

                return {regParam, dataEntry};
            }

            let CMD = WebMIDI.constants.COMMAND,
                CTL = WebMIDI.constants.CONTROL,
                channelSelect = getElem("channelSelect"),
                presetSelect = getElem("presetSelect"),
                channel = channelSelect.selectedIndex,
                channelGUIState = channelSelect.options[channel].hostState,
                preset = presetSelect.options[presetSelect.selectedIndex].preset,
                bankIndex = preset.bankIndex,
                presetIndex = preset.presetIndex,
                mixtureIndex = preset.mixtureIndex, // can be undefined
                bankMsg = getBankMsg(channel, bankIndex),
                presetMsg = getPresetMsg(channel, presetIndex),
                mixtureMsgs = getMixtureMessages(channel, mixtureIndex);

            synth.send(bankMsg);
            synth.send(presetMsg);
            synth.send(mixtureMsgs.regParam);
            synth.send(mixtureMsgs.dataEntry); // If mixtureMsgs.dataEntry.length is 2, the mixture index is set to undefined in the synth.

            channelGUIState.presetSelectIndex = presetSelect.selectedIndex;
        },

        // exported
        onTuningSelectChanged = function()
        {
            function findNearestA4FrequencySelectIndex(options, tuningA4MidiCents)
            {
                let returnIndex = -1, // frequency out of range
                    maxSelectMidiCents = options[0].midiCents + 0.5,
                    minSelectMidiCents = options[options.length - 1].midiCents - 0.5,
                    minDiff = Number.MAX_VALUE;

                console.assert(tuningA4MidiCents < maxSelectMidiCents && tuningA4MidiCents > minSelectMidiCents);

                for(var i = 0; i < options.length; i++)
                {
                    let option = options[i],
                        diff = Math.abs(option.midiCents - tuningA4MidiCents);

                    if(diff < minDiff)
                    {
                        minDiff = diff;
                        returnIndex = i;
                        if(minDiff === 0)
                        {
                            break;
                        }
                    }
                }

                console.assert(returnIndex >= 0);

                return returnIndex;
            }

            function getSysExTuningChangeMsg(channel, tuning)
            {
                let constants = WebMIDI.constants,
                    CMD = constants.COMMAND,
                    SYSEX = constants.SYSEX,
                    msgLength = 8 + (4 * tuning.length),
                    sysExMsg = new Uint8Array(msgLength),
                    i = 0;

                sysExMsg[i++] = CMD.SYSEX;
                sysExMsg[i++] = SYSEX.NON_REAL_TIME;
                sysExMsg[i++] = SYSEX.RESEARCH_DEVICE_ID;
                sysExMsg[i++] = SYSEX.MIDI_TUNING;
                sysExMsg[i++] = SYSEX.MIDI_TUNING_NOTE_CHANGES_NON_REAL_TIME_BANK;
                sysExMsg[i++] = channel;
                sysExMsg[i++] = tuning.length;
                for(let j = 0; j < tuning.length; ++j)
                {
                    let pitch = tuning[j],
                        basePitch = Math.floor(pitch),
                        // data1 and data2 encode cents * 16384
                        // cents = ((data2 & 0x7f) | ((data1 & 0x7f) << 7)) / 16384;
                        cents = Math.round((pitch - basePitch) * 16384),
                        data1 = (cents >> 7) & 0x7f,
                        data2 = (cents - (data1 << 7)) & 0x7f;

                    console.assert(cents === ((data2 & 0x7f) | ((data1 & 0x7f) << 7)));

                    sysExMsg[i++] = j;
                    sysExMsg[i++] = basePitch;
                    sysExMsg[i++] = data1;
                    sysExMsg[i++] = data2;
                }
                sysExMsg[msgLength - 1] = SYSEX.END_OF_MESSAGE;

                console.assert(i === msgLength - 1);

                return sysExMsg;
            }

            let channelSelect = getElem("channelSelect"),
                tuningGroupSelectIndex = getElem("tuningGroupSelect").selectedIndex,
                A4FrequencySelect = getElem("A4FrequencySelect"),
                tuningSelect = getElem("tuningSelect"),
                tuningSelectIndex = tuningSelect.selectedIndex,
                channel = channelSelect.selectedIndex,
                channelGUIState = channelSelect.options[channel].hostState,
                tuning = synth.tuningGroups[tuningGroupSelectIndex][tuningSelectIndex];

            if(A4FrequencySelect.disabled === false)
            {
                let tuningA4MidiCents = tuning[69];
                A4FrequencySelect.selectedIndex = findNearestA4FrequencySelectIndex(A4FrequencySelect.options, tuningA4MidiCents);
            }

            let sysExMsg = getSysExTuningChangeMsg(channel, tuning);

            synth.send(sysExMsg, performance.now());

            channelGUIState.tuningSelectIndex = tuningSelectIndex;
            channelGUIState.A4FrequencySelectIndex = A4FrequencySelect.selectedIndex;
        },

        //exported
        onA4FrequencySelectChanged = function()
        {
            let tuningGroupSelectIndex = getElem("tuningGroupSelect").selectedIndex,
                A4FrequencySelect = getElem("A4FrequencySelect"),
                A4Index = A4FrequencySelect.selectedIndex,
                A4Options = A4FrequencySelect.options,
                newA4MidiCents = A4Options[A4Index].midiCents,
                tuningSelect = getElem("tuningSelect"),
                tuningSelectIndex = tuningSelect.selectedIndex,
                tuning = synth.tuningGroups[tuningGroupSelectIndex][tuningSelectIndex],
                midiCentsDiff = newA4MidiCents - tuning[69];

            for(var i = 0; i < tuning.length; i++)
            {
                tuning[i] = tuning[i] + midiCentsDiff;
            }

            synth.tuningsFactory.finalizeTuning(tuning);

            onTuningSelectChanged();
        },

        sendCommand = function(commandIndex, data1, data2)
        {
            var CMD = WebMIDI.constants.COMMAND,
                status = commandIndex + currentChannel,
                message;

            switch(commandIndex)
            {
                case CMD.NOTE_ON:
                case CMD.NOTE_OFF:
                case CMD.AFTERTOUCH:
                case CMD.CONTROL_CHANGE:
                case CMD.PITCHWHEEL:
                    message = new Uint8Array([status, data1, data2]); // data1 can be RegisteredParameter or DataEntry controls
                    break;
                case CMD.PRESET:
                case CMD.CHANNEL_PRESSURE:
                    message = new Uint8Array([status, data1]);
                    break;
                default:
                    console.warn("Error: Not a command, or attempt to set the value of a command that has no value.");
            }
            synth.send(message, performance.now());
        },

        setOptions = function(select, options)
        {
            var i;

            for(i = select.options.length - 1; i >= 0; --i)
            {
                select.remove(i);
            }

            for(i = 0; i < options.length; ++i)
            {
                select.add(options[i]);
            }

            select.selectedIndex = 0;
        },

        // exported
        onWebAudioFontSelectChanged = function()
        {
            let webAudioFontSelect = getElem("webAudioFontSelect"),
                channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                channelGUIState = channelSelect.options[channel].hostState,
                presetSelect = getElem("presetSelect"),
                selectedSoundFontOption = webAudioFontSelect[webAudioFontSelect.selectedIndex],
                soundFont = selectedSoundFontOption.soundFont,
                presetOptionsArray = selectedSoundFontOption.presetOptionsArray;

            synth.setSoundFont(soundFont);

            setOptions(presetSelect, presetOptionsArray);

            presetSelect.selectedIndex = 0;
            onPresetSelectChanged();

            channelGUIState.fontSelectIndex = webAudioFontSelect.selectedIndex;
        },

        // exported (c.f. onWebAudioFontSelectChanged() )
        onTuningGroupSelectChanged = function()
        {
            let channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                channelGUIState = channelSelect.options[channel].hostState,
                tuningGroupSelect = getElem("tuningGroupSelect"),
                A4FrequencySelect = getElem("A4FrequencySelect"),
                tuningSelect = getElem("tuningSelect"),
                selectedTuningGroupOption = tuningGroupSelect[tuningGroupSelect.selectedIndex],
                selectedTuningGroupName = selectedTuningGroupOption.innerHTML,
                tuningOptionsArray = selectedTuningGroupOption.tuningOptionsArray;

            setOptions(tuningSelect, tuningOptionsArray);

            channelGUIState.tuningGroupSelectIndex = tuningGroupSelect.selectedIndex;

            A4FrequencySelect.disabled = selectedTuningGroupName.includes("warped");
            A4FrequencySelect.selectedIndex = 0;
            tuningSelect.selectedIndex = 0;

            onTuningSelectChanged();
        },

        // exported (c.f. onTuningSelectChanged() )
        onTriggerKeySelectChanged = function()
        {
            let triggerKeySelect = getElem("triggerKeySelect"),
                channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                channelGUIState = channelSelect.options[channel].hostState,
                channelNextActionIndex = channelGUIState.nextActionIndex;

            triggerKey = triggerKeySelect[triggerKeySelect.selectedIndex].key;
            channelGUIState.triggerKeySelectIndex = triggerKeySelect.selectedIndex;

            setTriggersDiv(channel, channelNextActionIndex);
        },

        // exported
        onContinueAtStartClicked = function()
        {
            function setPage2Display(synth)
            {
                function getWebAudioFontOptions(webAudioFonts)
                {
                    let options = [];

                    for(var fontIndex = 0; fontIndex < webAudioFonts.length; fontIndex++)
                    {
                        let option = new Option("webAudioFontOption"),
                            webAudioFont = webAudioFonts[fontIndex];

                        let presetOptionsArray = [];
                        for(let bankIndex = 0; bankIndex < webAudioFont.banks.length; bankIndex++)
                        {
                            let bank = webAudioFont.banks[bankIndex];
                            for(var j = 0; j < bank.length; j++)
                            {
                                let preset = bank[j],
                                    presetOption = new Option("presetOption");

                                presetOption.innerHTML = preset.name;
                                presetOption.preset = preset;
                                presetOption.preset.mixtureIndex = undefined; // could be omitted -- included here for instructional purposes only.


                                presetOptionsArray.push(presetOption);
                            }
                        }

                        option.innerHTML = webAudioFont.name;
                        option.soundFont = webAudioFont;
                        option.presetOptionsArray = presetOptionsArray; // used to set the presetSelect
                        option.url = "https://github.com/surikov/webaudiofont";

                        options.push(option);
                    }

                    return options;
                }
                function appendPresetMixtures(optionsArray, presetMixtures)
                {
                    for(var i = 0; i < presetMixtures.length; i++)
                    {
                        let presetMixture = presetMixtures[i],
                            presetOption = new Option("presetOption");

                        presetOption.innerHTML = presetMixture.name;
                        presetOption.preset = presetMixture;

                        optionsArray.push(presetOption);
                    }
                }
                function setPresetSelect()
                {
                    function appendPresetSelect(presetSelectCell, presetOptionsArray)
                    {
                        var presetSelect, input;

                        presetSelect = document.createElement("select");
                        presetSelect.id = "presetSelect";
                        presetSelect.className = "presetSelect";
                        setOptions(presetSelect, presetOptionsArray);
                        presetSelect.onchange = onPresetSelectChanged;
                        presetSelectCell.appendChild(presetSelect);

                        input = document.createElement("input");
                        input.type = "button";
                        input.className = "sendAgainButton";
                        input.value = "send again";
                        input.onclick = onPresetSelectChanged;
                        presetSelectCell.appendChild(input);
                    }

                    let webAudioFontSelect = getElem("webAudioFontSelect"),
                        presetSelectCell = getElem("presetSelectCell"),
                        presetOptionsArray = webAudioFontSelect[webAudioFontSelect.selectedIndex].presetOptionsArray;

                    appendPresetSelect(presetSelectCell, presetOptionsArray);
                }

                function getTuningGroupOptions(tuningGroups)
                {
                    let options = [];

                    for(let i = 0; i < tuningGroups.length; i++)
                    {
                        let tuningGroupOption = new Option("tuningGroupOption"),
                            tuningGroup = tuningGroups[i],
                            tuningOptionsArray = [];

                        for(var j = 0; j < tuningGroup.length; j++)
                        {
                            let tuningOption = new Option("tuningOption");

                            tuningOption.innerHTML = tuningGroup[j].name;
                            tuningOptionsArray.push(tuningOption);
                        }

                        tuningGroupOption.innerHTML = tuningGroup.name;
                        tuningGroupOption.tuningGroup = tuningGroup;
                        tuningGroupOption.tuningOptionsArray = tuningOptionsArray; // used to set the tuningSelect

                        options.push(tuningGroupOption);
                    }

                    return options;
                }

                function setA4FrequencySelect()
                {
                    let A4FrequencySelectCell = getElem("A4FrequencySelectCell"),
                        A4FrequencySelect = getElem("A4FrequencySelect"),
                        input = document.createElement("input"),
                        optionsArray = [];

                    for(var frequency = 440; frequency > 408; frequency -= 2)
                    {
                        let option = document.createElement("option"),
                            midiCentsDiff = synth.tuningsFactory.getCents(frequency / 440) / 100;

                        option.innerHTML = frequency.toString();
                        option.midiCents = Math.round((69 + midiCentsDiff) * 10000) / 10000;
                        optionsArray.push(option);
                    }

                    setOptions(A4FrequencySelect, optionsArray);

                    input.type = "button";
                    input.className = "sendAgainButton";
                    input.value = "send again";
                    input.onclick = onTuningSelectChanged;
                    A4FrequencySelectCell.appendChild(input);
                }

                function setTuningSelect()
                {
                    function appendTuningSelect(tuningSelectCell, tuningOptionsArray)
                    {
                        var tuningSelect;

                        tuningSelect = document.createElement("select");
                        tuningSelect.id = "tuningSelect";
                        tuningSelect.className = "tuningSelect";
                        setOptions(tuningSelect, tuningOptionsArray);
                        tuningSelect.onchange = onTuningSelectChanged;
                        tuningSelectCell.appendChild(tuningSelect);
                    }

                    let tuningGroupSelect = getElem("tuningGroupSelect"),
                        tuningSelectCell = getElem("tuningSelectCell"),
                        tuningOptionsArray = tuningGroupSelect[tuningGroupSelect.selectedIndex].tuningOptionsArray;

                    appendTuningSelect(tuningSelectCell, tuningOptionsArray);
                }

                function setTriggerKeySelect()
                {
                    let triggerKeySelect = getElem("triggerKeySelect"),
                        options = [];

                    triggerKey = 36;

                    // My 4 octave EMU keyboard has keys 36-84.
                    for(var key = triggerKey; key < 85; key++)
                    {
                        let option = new Option("triggerKeyOption");
                        option.innerHTML = key.toString();
                        option.key = key;
                        options.push(option);
                    }

                    let option = new Option("triggerKeyOption");
                    option.innerHTML = "none";
                    option.key = undefined;
                    options.push(option);

                    setOptions(triggerKeySelect, options);
                }

                function setChannelGUIStateFromLongControl(longControl, value)
                {
                    let channelSelect = getElem("channelSelect"),
                        channelGUIState = channelSelect.options[channelSelect.selectedIndex].hostState;

                    if(channelGUIState !== undefined)
                    {
                        let longControlID = longControl.id;

                        switch(longControlID)
                        {
                            case "aftertouchLongControl":
                                channelGUIState.aftertouchValue = value;
                                break;
                            case "pitchWheelLongControl":
                                channelGUIState.pitchWheelValue = value;
                                break;
                            case "modWheelLongControl":
                                channelGUIState.modWheelValue = value;
                                break;
                            case "volumeLongControl":
                                channelGUIState.volumeValue = value;
                                break;
                            case "panLongControl":
                                channelGUIState.panValue = value;
                                break;
                            case "reverberationLongControl":
                                channelGUIState.reverberationValue = value;
                                break;
                            case "pitchWheelSensitivityLongControl":
                                channelGUIState.pitchWheelSensitivityValue = value;
                                break;
                            default:
                                console.assert(false, "Unknown long control");
                                break;
                        }
                    }
                }

                function setCommandsAndControlsDivs()
                {
                    var CMD = WebMIDI.constants.COMMAND;

                    function sendLongControl(controlIndex, value)
                    {
                        sendCommand(CMD.CONTROL_CHANGE, controlIndex, value);
                    }

                    function sendShortControl(controlIndex)
                    {
                        function resetHostGUI(controlIndex)
                        {
                            let sendButton = getElem("sendButton");
                            if(sendButton.disabled === true)
                            {
                                sendButton.disabled = false;
                            }

                            if(controlIndex === WebMIDI.constants.CONTROL.ALL_CONTROLLERS_OFF)
                            {
                                for(let i = 0; i < allLongInputControls.length; ++i)
                                {
                                    let longInputControl = allLongInputControls[i];
                                    longInputControl.setValue(longInputControl.numberInputElem.defaultValue);
                                }
                            }
                        }

                        if(controlIndex === WebMIDI.constants.CONTROL.ALL_CONTROLLERS_OFF || controlIndex === WebMIDI.constants.CONTROL.ALL_SOUND_OFF)
                        {
                            resetHostGUI(controlIndex);
                        }

                        sendCommand(CMD.CONTROL_CHANGE, controlIndex);
                    }

                    // called by both commands and CCs
                    function getBasicLongInputControl(tr, name, defaultValue, infoString)
                    {
                        function getLongControlValue()
                        {
                            return this.rangeInputElem.valueAsNumber;
                        }

                        function getInputElemValue()
                        {
                            return this.valueAsNumber;
                        }

                        // sets synth and channel GUI state
                        function setLongControlValue(value)
                        {
                            this.rangeInputElem.value = value;
                            this.numberInputElem.value = value;

                            setChannelGUIStateFromLongControl(this, value);

                            this.numberInputElem.onchange(); // sets synth
                        }

                        let nameStrTD = document.createElement("td");
                        tr.appendChild(nameStrTD);
                        nameStrTD.className = "left";
                        nameStrTD.innerHTML = name;

                        // this td contains the slider, number and button inputs
                        let longControlTD = document.createElement("td");
                        longControlTD.id = name + "LongControl";
                        tr.appendChild(longControlTD);

                        let rangeInputElem = document.createElement("input"),
                            numberInputElem = document.createElement("input"),
                            buttonInputElem = document.createElement("input");

                        rangeInputElem.getValue = getInputElemValue;
                        //rangeInputElem.onchange = "WebMIDI.host.onLongControlComponentChanged()"; -- is set later
                        numberInputElem.getValue = getInputElemValue;
                        //numberInputElem.onchange = "WebMIDI.host.onLongControlComponentChanged()"; -- is set later
                        
                        longControlTD.appendChild(rangeInputElem);
                        longControlTD.appendChild(numberInputElem);
                        longControlTD.appendChild(buttonInputElem);

                        longControlTD.rangeInputElem = rangeInputElem;
                        longControlTD.numberInputElem = numberInputElem;
                        longControlTD.buttonInputElem = buttonInputElem;

                        longControlTD.getValue = getLongControlValue;
                        longControlTD.setValue = setLongControlValue;

                        // slider input                        
                        rangeInputElem.type = "range";
                        rangeInputElem.className = "midiSlider";
                        //rangeInputElem.id = name + "RangeInput";
                        rangeInputElem.twinInputElem = numberInputElem;
                        rangeInputElem.value = defaultValue;
                        rangeInputElem.defaultValue = defaultValue;
                        rangeInputElem.min = 0;
                        rangeInputElem.max = 127;

                        // number input                        
                        numberInputElem.type = "number";
                        numberInputElem.className = "number";
                        // numberInputElem.id = name + "NumberInput";
                        numberInputElem.twinInputElem = rangeInputElem;
                        numberInputElem.value = defaultValue;
                        numberInputElem.defaultValue = defaultValue;
                        numberInputElem.min = 0;
                        numberInputElem.max = 127;

                        // button input
                        buttonInputElem.type = "button";
                        buttonInputElem.className = "sendAgainButton";
                        buttonInputElem.value = "send again";
                        buttonInputElem.numberInputElem = numberInputElem;

                        let infoTD = document.createElement("td");
                        tr.appendChild(infoTD);
                        infoTD.innerHTML = infoString;

                        return longControlTD;
                    }

                    function setCommandsTable()
                    {
                        // sets the presetSelect and 
                        // returns an array of tr elements
                        function getCommandRows()
                        {
                            function getCommandInfos()
                            {
                                function getStandardCommandInfo(constants, cmdIndex)
                                {
                                    let info = {};

                                    info.name = constants.commandName(cmdIndex);
                                    info.defaultValue = constants.commandDefaultValue(cmdIndex);
                                    info.cmdIndex = cmdIndex;
                                    info.cmdString = "CMD " + cmdIndex.toString();

                                    return info;
                                }

                                let constants = WebMIDI.constants,
                                    cmd = constants.COMMAND,
                                    aftertouch = getStandardCommandInfo(constants, cmd.AFTERTOUCH),
                                    pitchWheel = getStandardCommandInfo(constants, cmd.PITCHWHEEL),
                                    commandInfos = [];

                                commandInfos.push(aftertouch);
                                commandInfos.push(pitchWheel);

                                return commandInfos;
                            }

                            function setCommandRow(tr, name, defaultValue, cmdIndex, cmdString)
                            {
                                function baseSendCommand(cmdIndex, value)
                                {
                                    if(cmdIndex === WebMIDI.constants.COMMAND.PITCHWHEEL)
                                    {
                                        // Note that:
                                        // 1. This function is called by the GUI controls, not by the EMU keyboard.
                                        // 2. The EMU keyboard generates different data1 values for the corresponding data2 values.
                                        // 3. The data1 values calculated here are such that
                                        //     a) if data2 is 64, data1 is 0.(MIDI Standard, same as EMU keyboard)
                                        //     b) data2 values are (differently) equidistant above and below data2=64.
                                        let data1 = 0,
                                            data2 = value; // default (for value === 64)

                                        if(data2 > 64)
                                        {
                                            data1 = data2;
                                        }
                                        else if(data2 < 64)
                                        {
                                            data1 = data2 * 2; // data1 is in range 0..126 for data2 0..63
                                        }

                                        sendCommand(cmdIndex, data1, data2);
                                    }
                                    else if(cmdIndex === WebMIDI.constants.COMMAND.AFTERTOUCH)
                                    {
                                        if(value > 0 && notesAreSounding)
                                        {
                                            // in this GUI, only the note in the notesDivIndexInput2 gets the aftertouch
                                            let noteIndex = getElem('notesDivIndexInput2').value;
                                            sendCommand(cmdIndex, noteIndex, value);
                                        }
                                    }
                                    else
                                    {
                                        // can only be AFTERTOUCH or PITCHWHEEL
                                        console.assert(false, "Error");
                                    }
                                }
                                function onCommandInputChanged(event)
                                {
                                    var target = (event === undefined) ? this : event.currentTarget,
                                        value = target.valueAsNumber,
                                        cmdIndex = target.cmdIndex;

                                    target.twinInputElem.value = value;

                                    setChannelGUIStateFromLongControl(target.parentElement, value);

                                    baseSendCommand(cmdIndex, value);
                                }

                                function onSendCommandAgainButtonClick(event)
                                {
                                    var target = (event === undefined) ? this : event.currentTarget,
                                        numberInputElem = target.children[2],
                                        value = numberInputElem.valueAsNumber,
                                        cmdIndex = numberInputElem.cmdIndex;

                                    baseSendCommand(cmdIndex, value);
                                }

                                let longInputControlTD = getBasicLongInputControl(tr, name, defaultValue, cmdString);                                                                    

                                longInputControlTD.cmdIndex = cmdIndex;
                                longInputControlTD.rangeInputElem.cmdIndex = cmdIndex;
                                longInputControlTD.numberInputElem.cmdIndex = cmdIndex;
                                longInputControlTD.rangeInputElem.onchange = onCommandInputChanged;
                                longInputControlTD.numberInputElem.onchange = onCommandInputChanged;
                                longInputControlTD.buttonInputElem.onchange = onSendCommandAgainButtonClick;

                                allLongInputControls.push(longInputControlTD);
                            }

                            let rval = [],
                                commandInfos = getCommandInfos();

                            for(let i = 0; i < commandInfos.length; ++i)
                            {
                                let commandInfo = commandInfos[i],
                                    name = commandInfo.name,
                                    defaultValue = commandInfo.defaultValue,
                                    cmdIndex = commandInfo.cmdIndex,
                                    cmdString = commandInfo.cmdString;

                                    let tr = document.createElement("tr");
                                    rval.push(tr);
                                    setCommandRow(tr, name, defaultValue, cmdIndex, cmdString);
                            }

                            return rval;
                        }

                        let commandsTable = getElem("commandsTable"),
                            commandRows = getCommandRows();

                        for(let i = 0; i < commandRows.length; ++i)
                        {
                            let tr = commandRows[i];
                            commandsTable.appendChild(tr);
                        }
                    }

                    function setControlsTable()
                    {
                        // returns an array of tr elements
                        function getControlRows()
                        {
                            // 3-byte controls
                            function setLongControlRow(tr, name, defaultValue, ccIndex, regParam, ccString)
                            {
                                function onControlInputChanged(event)
                                {
                                    var target = (event === undefined) ? this: event.currentTarget,
                                        value = target.valueAsNumber,
                                        ccIndex = target.ccIndex;

                                    target.twinInputElem.value = value;

                                    setChannelGUIStateFromLongControl(target.parentElement, value);

                                    sendLongControl(ccIndex, value);
                                }

                                function onRegParamControlInputChanged(event)
                                {
                                    var target = (event === undefined) ? this : event.currentTarget,
                                        value = target.valueAsNumber,
                                        ccIndex = target.ccIndex,
                                        regParamIndex = target.regParam;

                                    target.twinInputElem.value = value;

                                    setChannelGUIStateFromLongControl(target.parentElement, value);

                                    sendLongControl(WebMIDI.constants.CONTROL.REGISTERED_PARAMETER, regParamIndex);
                                    sendLongControl(ccIndex, value);
                                }

                                function onSendControlAgainButtonClick(event)
                                {
                                    var numberInputElem = event.currentTarget.numberInputElem,
                                        ccIndex = numberInputElem.ccIndex,
                                        value = numberInputElem.valueAsNumber;

                                    sendLongControl(ccIndex, value);
                                }

                                function onSendRegParamControlAgainButtonClick(event)
                                {
                                    var numberInputElem = event.currentTarget.numberInputElem,
                                        ccIndex = numberInputElem.ccIndex,
                                        regParamIndex = numberInputElem.regParam,
                                        value = numberInputElem.valueAsNumber;

                                    sendLongControl(WebMIDI.constants.CONTROL.REGISTERED_PARAMETER, regParamIndex);
                                    sendLongControl(ccIndex, value);
                                }

                                let longInputControlTD = getBasicLongInputControl(tr, name, defaultValue, ccString);

                                longInputControlTD.ccIndex = ccIndex;
                                longInputControlTD.rangeInputElem.ccIndex = ccIndex;
                                longInputControlTD.numberInputElem.ccIndex = ccIndex;

                                if(regParam === undefined)
                                {
                                    longInputControlTD.rangeInputElem.onchange = onControlInputChanged;
                                    longInputControlTD.numberInputElem.onchange = onControlInputChanged;
                                    longInputControlTD.buttonInputElem.onclick = onSendControlAgainButtonClick;
                                }
                                else
                                {
                                    longInputControlTD.rangeInputElem.regParam = regParam;
                                    longInputControlTD.numberInputElem.regParam = regParam;
                                    longInputControlTD.rangeInputElem.onchange = onRegParamControlInputChanged;
                                    longInputControlTD.numberInputElem.onchange = onRegParamControlInputChanged;
                                    longInputControlTD.buttonInputElem.onclick = onSendRegParamControlAgainButtonClick;
                                }

                                allLongInputControls.push(longInputControlTD);
                            }

                            // 2-byte uControls
                            function setShortControlRow(tr, name, ccIndex, ccString)
                            {
                                var
                                    button,
                                    td = document.createElement("td");

                                function onSendShortControlButtonClick(event)
                                {
                                    sendShortControl(event.currentTarget.ccIndex);
                                }

                                tr.appendChild(td);
                                td.className = "left";
                                td.innerHTML = name;

                                td = document.createElement("td");
                                tr.appendChild(td);
                                button = document.createElement("input");
                                button.type = "button";
                                button.className = "sendButton";
                                button.value = "send";
                                button.ccIndex = ccIndex;
                                button.onclick = onSendShortControlButtonClick;
                                td.appendChild(button);

                                let node = document.createTextNode(ccString);
                                td.appendChild(node);
                            }

                            function getControlInfos()
                            {
                                function getStandardControlInfo(constants, ccIndex)
                                {
                                    let info = {};

                                    info.name = constants.controlName(ccIndex);
                                    info.defaultValue = constants.controlDefaultValue(ccIndex);
                                    info.ccIndex = ccIndex;
                                    info.ccString = "CC " + ccIndex.toString();

                                    return info;
                                }

                                function getRegParamControlInfo(name, defaultValue, regParam)
                                {
                                    let info = {};

                                    info.name = name;
                                    info.defaultValue = defaultValue;
                                    info.regParam = regParam;

                                    info.ccIndex = WebMIDI.constants.CONTROL.DATA_ENTRY; // this will be the same for all RegParam controls
                                    info.ccString = ""; // this will be the same for all RegParam controls

                                    return info;

                                }

                                let constants = WebMIDI.constants,
                                    ctl = constants.CONTROL,
                                    modWheelData = getStandardControlInfo(constants, ctl.MODWHEEL),
                                    volumeData = getStandardControlInfo(constants, ctl.VOLUME),
                                    panData = getStandardControlInfo(constants, ctl.PAN),
                                    reverberationData = getStandardControlInfo(constants, ctl.REVERBERATION),
                                    allControllersOff = getStandardControlInfo(constants, ctl.ALL_CONTROLLERS_OFF),
                                    allSoundOff = getStandardControlInfo(constants, ctl.ALL_SOUND_OFF),
                                    pitchWheelSensitivityData =
                                        getRegParamControlInfo("pitchWheelSensitivity",
                                            constants.MISC.MIDI_DEFAULT_PITCHWHEEL_SENSITIVITY,
                                            synth.REGPARAM_SET_PITCHWHEEL_SENSITIVITY),
                                    controlInfos = [];

                                controlInfos.push(modWheelData);
                                controlInfos.push(volumeData);
                                controlInfos.push(panData);
                                controlInfos.push(reverberationData);
                                controlInfos.push(pitchWheelSensitivityData);
                                controlInfos.push(allControllersOff);
                                controlInfos.push(allSoundOff);

                                return controlInfos;
                            }

                            let rval = [],
                                controlInfos = getControlInfos();

                            for(let i = 0; i < controlInfos.length; ++i)
                            {
                                let c = WebMIDI.constants,
                                    control = c.CONTROL,
                                    controlInfo = controlInfos[i],
                                    name = controlInfo.name,
                                    defaultValue = controlInfo.defaultValue,
                                    ccIndex = controlInfo.ccIndex,
                                    regParam = controlInfo.regParam, // can be undefined
                                    ccString = controlInfo.ccString,
                                    tr = document.createElement("tr");

                                rval.push(tr);

                                if(ccIndex === control.ALL_CONTROLLERS_OFF)
                                {
                                    name = name + " (set defaults)";
                                    setShortControlRow(tr, name, ccIndex, ccString);
                                }
                                else if(ccIndex === control.ALL_SOUND_OFF)
                                {
                                    setShortControlRow(tr, name, ccIndex, ccString);
                                }
                                else
                                {
                                    setLongControlRow(tr, name, defaultValue, ccIndex, regParam, ccString);
                                }
                            }

                            return rval;
                        }

                        let controlsTable = getElem("controlsTable"),
                            controlRows = getControlRows();

                        for(let i = 0; i < controlRows.length; ++i)
                        {
                            let tr = controlRows[i];
                            controlsTable.appendChild(tr);
                        }
                    }

                    allLongInputControls.length = 0;

                    setCommandsTable();

                    setControlsTable();

                    getElem("commandsAndControlsDiv").style.display = "block";

                    sendShortControl(WebMIDI.constants.CONTROL.ALL_CONTROLLERS_OFF);
                }

                function getDefaultChannelGUIStates()
                {
                    let channelOptions = getElem("channelSelect").options,
                        fontSelectIndex = getElem("webAudioFontSelect").selectedIndex,
                        presetSelectIndex = getElem("presetSelect").selectedIndex,
                        tuningGroupSelectIndex = getElem("tuningGroupSelect").selectedIndex,
                        tuningSelectIndex = getElem("tuningSelect").selectedIndex,
                        A4FrequencySelectIndex = getElem("A4FrequencySelect").selectedIndex,
                        triggerKeySelectIndex = getElem("triggerKeySelect").selectedIndex,
                        aftertouchValue = getElem("aftertouchLongControl").getValue(),
                        pitchWheelValue = getElem("pitchWheelLongControl").getValue(),
                        modWheelValue = getElem("modWheelLongControl").getValue(),
                        volumeValue = getElem("volumeLongControl").getValue(),
                        panValue = getElem("panLongControl").getValue(),
                        reverberationValue = getElem("reverberationLongControl").getValue(),
                        pitchWheelSensitivityValue = getElem("pitchWheelSensitivityLongControl").getValue();


                    for(let i = 0; i < channelOptions.length; i++)
                    {
                        let channelOption = channelOptions[i],
                            hostState = {};

                        hostState.fontSelectIndex = fontSelectIndex;
                        hostState.presetSelectIndex = presetSelectIndex;
                        hostState.tuningGroupSelectIndex = tuningGroupSelectIndex;
                        hostState.tuningSelectIndex = tuningSelectIndex;
                        hostState.A4FrequencySelectIndex = A4FrequencySelectIndex;
                        hostState.triggerKeySelectIndex = triggerKeySelectIndex;
                        hostState.nextActionIndex = 0;
                        hostState.aftertouchValue = aftertouchValue;
                        hostState.pitchWheelValue = pitchWheelValue;
                        hostState.modWheelValue = modWheelValue;
                        hostState.volumeValue = volumeValue;
                        hostState.panValue = panValue;
                        hostState.reverberationValue = reverberationValue;
                        hostState.pitchWheelSensitivityValue = pitchWheelSensitivityValue;

                        channelOption.hostState = hostState;
                    }
                }

                let
                    webAudioFontDiv = getElem("webAudioFontDiv"),
                    tuningDiv = getElem("tuningDiv"),
                    triggersDiv = getElem("triggersDiv"),
                    webAudioFontSelect = getElem("webAudioFontSelect"),
                    tuningGroupSelect = getElem("tuningGroupSelect");

                console.assert(synth.name === "ResidentSynth", "Error: this app only uses the ResidentSynth");

                let webAudioFontOptions = getWebAudioFontOptions(synth.webAudioFonts);
                appendPresetMixtures(webAudioFontOptions[0].presetOptionsArray, synth.presetMixtures);
                setOptions(webAudioFontSelect, webAudioFontOptions);
                setPresetSelect();
                webAudioFontSelect.selectedIndex = 0;
                webAudioFontDiv.style.display = "block";

                let tuningGroupOptions = getTuningGroupOptions(synth.tuningGroups);
                setOptions(tuningGroupSelect, tuningGroupOptions);
                tuningGroupSelect.selectedIndex = 0;
                setTuningSelect();
                setA4FrequencySelect();
                tuningDiv.style.display = "block";

                setTriggerKeySelect();
                setTriggersDiv(0, 0);
                triggersDiv.style.display = "block";

                setCommandsAndControlsDivs();

                getDefaultChannelGUIStates();

                // must be called after all the GUI controls have been set.
                // It calls all the synth's public control functions.
                onChannelSelectChanged();

                getElem("notesDiv").style.display = "block";
            }

            // Its important to call this function after user interaction with the GUI.
            synth.open();

            setInputDeviceEventListener(getElem("inputDeviceSelect"));

            getElem("continueAtStartButtonDiv").style.display = "none";

            // This function should initialize the synth with the (default) values of all the host's controls
            // by calling the corresponding functions in the synth's public interface.
			setPage2Display(synth);
		},

        // exported
		noteCheckboxClicked = function()
		{
			var
				note1Checkbox = getElem("sendNote1Checkbox"),
				note2Checkbox = getElem("sendNote2Checkbox");

			if((!note1Checkbox.checked) && (!note2Checkbox.checked))
			{
				note2Checkbox.checked = true;
			}
		},

        // exported
		doNotesOn = function()
        {
            function sendNoteOn(noteIndex, noteVelocity)
            {
                sendCommand(WebMIDI.constants.COMMAND.NOTE_ON, noteIndex, noteVelocity);
            }

            var
                aftertouchValue = getElem('aftertouchLongControl').getValue(),
				note1Checkbox = getElem("sendNote1Checkbox"),
				note1Index = getElem("notesDivIndexInput1").valueAsNumber,
				note1Velocity = getElem("notesDivVelocityInput1").valueAsNumber,
				note2Checkbox = getElem("sendNote2Checkbox"),
				note2Index = getElem("notesDivIndexInput2").valueAsNumber,
				note2Velocity = getElem("notesDivVelocityInput2").valueAsNumber,
				holdCheckbox = getElem("holdCheckbox"),
                sendButton = getElem("sendButton");

			if(holdCheckbox.checked === true)
			{
				sendButton.disabled = true;
			}

			if(note1Checkbox.checked)
			{
				sendNoteOn(note1Index, note1Velocity);
			}
			if(note2Checkbox.checked)
			{
                sendNoteOn(note2Index, note2Velocity);
                // note that in this GUI, aftertouch is only applied to note2
                if(aftertouchValue > 0)
                {
                    sendCommand(WebMIDI.constants.COMMAND.AFTERTOUCH, note2Index, aftertouchValue);
                }
            }
            notesAreSounding = true;
		},

        // exported
		doNotesOff = function()
        {
            function sendNoteOff(noteIndex, noteVelocity)
            {
                var
                    NOTE_ON = WebMIDI.constants.COMMAND.NOTE_ON,
                    NOTE_OFF = WebMIDI.constants.COMMAND.NOTE_OFF;

                if(synth.commands.indexOf(NOTE_OFF) >= 0)
                {
                    sendCommand(NOTE_OFF, noteIndex, noteVelocity);
                }
                else
                {
                    sendCommand(NOTE_ON, noteIndex, 0);
                }
            }

			var
				note1Checkbox = getElem("sendNote1Checkbox"),
				note1Index = getElem("notesDivIndexInput1").valueAsNumber,
				note1Velocity = getElem("notesDivVelocityInput1").valueAsNumber,
				note2Checkbox = getElem("sendNote2Checkbox"),
				note2Index = getElem("notesDivIndexInput2").valueAsNumber,
				note2Velocity = getElem("notesDivVelocityInput2").valueAsNumber;

			if(note1Checkbox.checked)
			{
				sendNoteOff(note1Index, note1Velocity);
			}
			if(note2Checkbox.checked)
			{
				sendNoteOff(note2Index, note2Velocity);
            }
            notesAreSounding = false;
		},

        // exported
        holdCheckboxClicked = function()
        {
            let holdCheckbox = getElem("holdCheckbox");

            doNotesOff();

            if(holdCheckbox.checked === false)
            {
                getElem("sendButton").disabled = false;
            }
        },

		init = function()
        {
            function setupInputDevice()
            {
                function setInputDeviceSelect(midiAccess)
                {
                    let iDevSelect = getElem("inputDeviceSelect"),
                        option;

                    iDevSelect.options.length = 0; // important when called by midiAccess.onstatechange 

                    option = document.createElement("option");
                    if(midiAccess !== null)
                    {
                        option.text = "choose a MIDI input device";
                        iDevSelect.add(option, null);
                        midiAccess.inputs.forEach(function(port)
                        {
                            //console.log('input id:', port.id, ' input name:', port.name);
                            option = document.createElement("option");
                            option.inputDevice = port;
                            option.text = port.name;
                            iDevSelect.add(option, null);
                        });
                        iDevSelect.disabled = false;
                    }
                    else
                    {
                        option.text = "There are no MIDI input devices available";
                        iDevSelect.add(option, null);
                        iDevSelect.disabled = true;
                    }

                    for(var i = iDevSelect.options.length - 1; i >= 0; --i)
                    {
                        iDevSelect.selectedIndex = i;
                        if(iDevSelect[iDevSelect.selectedIndex].text === "E-MU Xboard49")
                        {
                            inputDevice = iDevSelect[iDevSelect.selectedIndex].inputDevice;
                            break;
                        }
                    }
                }

                function onSuccessCallback(midiAccess)
                {
                    // Add the midiAccess.inputs to the inputDeviceSelect.
                    setInputDeviceSelect(midiAccess);
                }

                // This function will be called either
                // if the browser does not support the Web MIDI API,
                // or if the user refuses permission to use his hardware MIDI devices.
                function onErrorCallback()
                {
                    alert("Error getting midiAccess for the inputDevice.");
                }

                navigator.requestMIDIAccess().then(onSuccessCallback, onErrorCallback);
            }
            function setInitialDivsDisplay()
            {
                getElem("loadingMsgDiv").style.display = "none";
                getElem("continueAtStartButtonDiv").style.display = "block";

                getElem("webAudioFontDiv").style.display = "none";
                getElem("tuningDiv").style.display = "none";
                getElem("triggersDiv").style.display = "none";
                getElem("commandsAndControlsDiv").style.display = "none";

                getElem("notesDiv").style.display = "none";
            }
            
            setupInputDevice();
            synth = new WebMIDI.residentSynth.ResidentSynth(); // loads definitions from synthConfig.
			setInitialDivsDisplay();
		},

		publicAPI =
		{
            onInputDeviceSelectChanged: onInputDeviceSelectChanged,

			onContinueAtStartClicked: onContinueAtStartClicked,

			webAudioFontWebsiteButtonClick: webAudioFontWebsiteButtonClick,

            onChannelSelectChanged: onChannelSelectChanged,
            onWebAudioFontSelectChanged: onWebAudioFontSelectChanged,
            onPresetSelectChanged: onPresetSelectChanged,
            onTuningGroupSelectChanged: onTuningGroupSelectChanged,
            onTuningSelectChanged: onTuningSelectChanged,
            onA4FrequencySelectChanged: onA4FrequencySelectChanged,
            onTriggerKeySelectChanged: onTriggerKeySelectChanged,
           // onTriggerActionSelectChanged: onTriggerActionSelectChanged,

			noteCheckboxClicked: noteCheckboxClicked,
			holdCheckboxClicked: holdCheckboxClicked,

			doNotesOn: doNotesOn,
			doNotesOff: doNotesOff
		};
	// end var

	init();

	return publicAPI;

}(document));
